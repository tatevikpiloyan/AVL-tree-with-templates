#include <iostream>
#include <initializer_list>

template <typename T>
class AVL
{
public:
  template<typename>
  struct Node
  {
    T data;
    Node* left;
    Node* right;
    Node* parent;
    int balfact;
    Node() : left(nullptr), right(nullptr), parent(nullptr) {}
  };
  
private:
  Node<T>* root;

public:
  AVL() : root(nullptr) {}
  
  AVL(T data)
    {
        root = new Node<T>;
        this->data = data;
    }
  
  AVL(std::initializer_list<T> elem)
  {
    for (auto init : elem)
    {
      insert(init);
    }
  }
  
  AVL(const AVL& node)
  {
    root = deep_copy(node.root);
  }
  
  AVL(AVL&& node)
  {
    root = node.root;
    node.root = nullptr;
  }
  
  ~AVL()
  {
    if(root != nullptr)
    {
      clear(root);
    }
  }
  
public:
  AVL& operator=(const AVL& node)
    {
        if (root == node.root)
        {
            return this;
        }
        if (root != nullptr)
        {
            clear(root);
        }
        root = deep_copy(node.root);
        return *this;
    }

    AVL& operator=(AVL&& node)
    {
        if (root == node.root)
        {
            return this;
        }
        if (root != nullptr)
        {
            clear(root);
        }
        root = node.root;
        node.root = nullptr;
        return *this;
    }

    friend std::ostream& operator<<(std::ostream& os, const AVL& obj)
    {
        print(os, obj.root);
        return os;
    }

    friend bool operator==(const AVL& obj1, const AVL& obj2)
    {   
        if (get_number_of_nodes(obj1.root) != get_number_of_nodes(obj2.root))
        {
            return false;
        }   
        return cmp(obj1.root, obj2.root);
    }

    friend bool operator!=(const AVL& obj1, const AVL& obj2)
    {   
        return !(obj1 == obj2);
    }
  
private:
  Node* deep_copy(Node<T>* node_ptr)
  {
    Node<T>* ptr = nullptr;
    if (node_ptr == nullptr)
    {
      return ptr;
    }
    ptr = new Node<T>();
    ptr->data = node_ptr->data;
    ptr->left = deep_copy(node_ptr->left);
    ptr->right = deep_copy(node_ptr->right);
    return ptr;
  }
  
  void print(std::ostream& os, const Node<T>* root)
    {
        if (root == nullptr)
        {
            return;
        }
        print(os, root->left);
        os << root->data << ' ';
        print(os, root->right);
    }
    
    bool cmp(const Node<T>* obj1, const Node<T>* obj2)
    {
        if (obj1 == nullptr && obj2 == nullptr)
        {
            return true;
        }
        if (obj1->data != obj2->data)
        {
            return false;
        }
        return cmp(obj1->left, obj2->left) && cmp(obj1->right, obj2->right);
    }

public:
  void clear(Node<T>* ptr)
  {
    if (ptr == nullptr)
    {
      return;
    }
    clear(ptr->left);
    clear(ptr->right);
    delete ptr;
    ptr = nullptr;
  }
   
   int get_number_of_nodes(const Node<T>* ptr)
    {
        if (ptr == nullptr)
        {
            return 0;
        }
        return 1 + get_number_of_nodes(ptr->left) + get_number_of_nodes(ptr->right);
    }
    
    void preorder(const Node<T>* node)
    {
        if (node == nullptr)
        {
            return;
        }
        std::cout << node->data << ' ';
        preorder(node->left);
        preorder(node->right);
    }
    
    void inorder(const Node<T>* node)
    {
        if (node == nullptr)
        {
            return;
        }
        inorder(node->left);
        std::cout << node->data << ' ';
        inorder(node->right);
    }
    
    void postorder(const Node<T>* node)
    {
        if (node == nullptr)
        {
            return;
        }
        postorder(node->left);
        postorder(node->right);
        std::cout << node->data << ' ';
    }

    T get_root_data()
    {
        return root->data;
    }

    int get_height(const Node<T>* node)
    {
        if (node == nullptr)
        {
            return 0;
        }
        return 1 + ((get_height(node->left) > get_height(node->right)) ? get_height(node->left) : get_height(node->right));
    }
    
    bool contains(const Node<T>* node, T data)
    {
        if (node == nullptr)
        {
            return false;
        }
        if (node->data == data)
        {
            return true;
        }
        else if (node->data > data)
        {
            return contains(node->left, data);
        }
        else if (node->data < data)
        {
            return contains(node->right, data);
        }
        return 0;
    }
};
