#include <iostream>
#include <initializer_list>

template <typename T>
class AVL
{
public:
  struct Node
  {
    T data;
    Node* left;
    Node* right;
    Node* parent;
    int balfact;
  };
  
  Node* root;

public:
  AVL() : root(nullptr) {}
  
  AVL(std::initializer_list<T> elem)
  {
    for (auto init : elem)
    {
      insert(root, init);
    }
  }
  
  AVL(const AVL& node)
  {
    root = deep_copy(node.root);
  }
  
  AVL(AVL&& node)
  {
    root = node.root;
    node.root = nullptr;
  }
  
  ~AVL()
  {
    if(root != nullptr)
    {
      clear(root);
    }
  }
  
public:
  AVL& operator=(const AVL& node)
    {
        if (root != nullptr)
        {
            clear(root);
        }
        root = deep_copy(node.root);
        return *this;
    }

    AVL& operator=(AVL&& node)
    {
        if (root != nullptr)
        {
            clear(root);
        }
        root = node.root;
        node.root = nullptr;
        return *this;
    }

    friend std::ostream& operator<<(std::ostream& os, const AVL& obj)
    {
        print(os, obj.root);
        return os;
    }

    friend bool operator==(const AVL& obj1, const AVL& obj2)
    {   
        if (get_number_of_nodes(obj1.root != get_number_of_nodes(obj2.root)))
        {
            return false;
        }   
        return cmp(obj1.root, obj2.root);
    }

    friend bool operator!=(const AVL& obj1, const AVL& obj2)
    {   
        if (get_number_of_nodes(obj1.root != get_number_of_nodes(obj2.root)))
        {
            return true;
        }  
        return !(obj1 == obj2);
    }
  
private:
  Node* deep_copy(Node* node_ptr)
  {
    Node* ptr = nullptr;
    if (node_ptr == nullptr)
    {
      return ptr;
    }
    ptr = new Node();
    ptr->data = node_ptr->data;
    ptr->left = deep_copy(node_ptr->left);
    ptr->right = deep_copy(node_ptr->right);
    return ptr;
  }
  
  static void print(std::ostream& os, const Node* root)
    {
        if (root == nullptr)
        {
            return;
        }
        os << root->data << ' ';
        print(os, root->left);
        print(os, root->right);
    }
    
    static bool cmp(const Node* obj1, const Node* obj2)
    {
        if (obj1 == nullptr)
        {
            if (obj2 == obj1)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        if (obj2 == nullptr)
        {
            if (obj1 == obj2)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        if (obj1->data != obj2->data)
        {
            return false;
        }
        return cmp(obj1->left, obj2->left) && cmp(obj1->right, obj2->right);
    }

public:
  void clear(Node* ptr)
  {
    if (ptr == nullptr)
    {
      return;
    }
    clear(ptr->left);
    clear(ptr->right);
    delete ptr;
    ptr = nullptr;
  }
   
   static int get_number_of_nodes(const Node* ptr)
    {
        if (ptr == nullptr)
        {
            return 0;
        }
        return 1 + get_number_of_nodes(ptr->left) + get_number_of_nodes(ptr->right);
    }
    
    void preorder(const Node* node)
    {
        if (node == nullptr)
        {
            return;
        }
        std::cout << node->data << ' ';
        preorder(node->left);
        preorder(node->right);
    }
    
    void inorder(const Node* node)
    {
        if (node == nullptr)
        {
            return;
        }
        inorder(node->left);
        std::cout << node->data << ' ';
        inorder(node->right);
    }
    
    void postorder(const Node* node)
    {
        if (node == nullptr)
        {
            return;
        }
        postorder(node->left);
        postorder(node->right);
        std::cout << node->data << ' ';
    }

    T get_root_data()
    {
        return root->data;
    }

    int get_height(const Node* node)
    {
        if (node == nullptr)
        {
            return 0;
        }
        return 1 + ((get_height(node->left) > get_height(node->right)) ? get_height(node->left) : get_height(node->right));
    }
    
    bool contains(const Node* node, T data)
    {
        if (node == nullptr)
        {
            return false;
        }
        if (node->data == data)
        {
            return true;
        }
        else if (node->data > data)
        {
            return contains(node->left, data);
        }
        else if (node->data < data)
        {
            return contains(node->right, data);
        }
        return 0;
    }
};
