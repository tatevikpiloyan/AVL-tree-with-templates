#include <iostream>
#include <initializer_list>

template <typename T>
class AVL
{
public:
    template<typename>
    struct Node
    {
        T data;
        Node* left;
        Node* right;
        Node* parent;
        int balfactor;
        Node() : left(nullptr), right(nullptr), parent(nullptr) {}
        Node(T elem) : data(elem), left(nullptr), right(nullptr), parent(nullptr) {}
    };


    Node<T>* root;

public:
    AVL() : root(nullptr) {}

    AVL(T data)
    {
        root = new Node<T>(data);
    }
  
    AVL(std::initializer_list<T> elem)
    {
        for(auto init : elem)
        {
            insert(init);
        }
    }
  
    AVL(const AVL& node)
    {
        root = deep_copy(node.root);
    }
  
    AVL(AVL&& node)
    {
        root = node.root;
        node.root = nullptr;
    }
  
    ~AVL()
    {
        if (root != nullptr)
        {
            clear_helper(root);
        }
    }
  
public:
    AVL& operator=(const AVL& node)
    {
        if (this == &node)
        {
            return *this;
        }
        if (root != nullptr)
        {
            clear_helper(root);
        }
        root = deep_copy(node.root);
        return *this;
    }

    AVL& operator=(AVL&& node)
    {
        if (this == &node)
        {
            return *this;
        }
        if (root != nullptr)
        {
            clear_helper(root);
        }
        root = node.root;
        node.root = nullptr;
        return *this;
    }

    friend std::ostream& operator<<(std::ostream& os, const AVL& obj)
    {
        obj.print(os, obj.root);
        return os;
    }

    friend bool operator==(const AVL& obj1, const AVL& obj2)
    {
        if (obj1.get_number_of_nodes() != obj2.get_number_of_nodes())
        {
            return false;
        }
        return obj1.cmp(obj1.root, obj2.root);
    }

    friend bool operator!=(const AVL& obj1, const AVL& obj2)
    {
        return !(obj1 == obj2);
    }
  
private:
    Node<T>* deep_copy(Node<T>* node_ptr)
    {
        Node<T>* ptr = nullptr;
        if (node_ptr == nullptr)
        {
            return ptr;
        }
        ptr = new Node<T>();
        ptr->data = node_ptr->data;
        ptr->left = deep_copy(node_ptr->left);
        ptr->right = deep_copy(node_ptr->right);
        return ptr;
    }
  
    void print(std::ostream& os, const Node<T>* root) const
    {
        if (root == nullptr)
        {
            return;
        }
        print(os, root->left);
        os << root->data << ' ';
        print(os, root->right);
    }
    
    bool cmp(const Node<T>* obj1, const Node<T>* obj2) const
    {
        if (obj1 == nullptr && obj2 == nullptr)
        {
            return true;
        }
        if (obj1->data != obj2->data)
        {
            return false;
        }
        return cmp(obj1->left, obj2->left) && cmp(obj1->right, obj2->right);
    }
    
    void clear_helper(Node<T>* ptr)
    {
        if (ptr == nullptr)
        {
            return;
        }
        clear_helper(ptr->left);
        clear_helper(ptr->right);
        delete ptr;
        ptr = nullptr;
    }
    
    int nodes_number(const Node<T>* ptr) const
    {
        if (ptr == nullptr)
        {
            return 0;
        }
        return 1 + nodes_number(ptr->left) + nodes_number(ptr->right);
    }
    
    int node_height(const Node<T>* node) const
    {
        if (node == nullptr)
        {
            return 0;
        }
        return 1 + ((node_height(node->left) > node_height(node->right)) ? node_height(node->left) : node_height(node->right));
    }
    
    bool contains_helper(const Node<T>* node, T data) const
    {
        if (node == nullptr)
        {
            return false;
        }
        if (node->data == data)
        {
            return true;
        }
        else if (node->data > data)
        {
            return contains_helper(node->left, data);
        }
        else if (node->data < data)
        {
            return contains_helper(node->right, data);
        }
    }
    
    void preorder_helper(const Node<T>* node)
    {
        if (node == nullptr)
        {   
            return;
        }
        std::cout << node->data << ' ';
        preorder_helper(node->left);
        preorder_helper(node->right);
    }
    
    void inorder_helper(const Node<T>* node)
    {
        if (node == nullptr)
        {   
            return;
        }
        inorder_helper(node->left);
        std::cout << node->data << ' ';
        inorder_helper(node->right);
    }
    
    void postorder_helper(const Node<T>* node)
    {
        if (node == nullptr)
        {   
            return;
        }
        postorder_helper(node->left);
        postorder_helper(node->right);
        std::cout << node->data << ' ';
    }
    
    void levelorder_helper(const Node<T>* node)
    {
        if (node == nullptr)
        {
            return;
        }
        if (node->left != nullptr)
        {
            std::cout << node->left->data << ' ';
        }
        if (node->right != nullptr)
        {
            std::cout << node->right->data << ' ';
        }
        levelorder_helper(node->left);
        levelorder_helper(node->right);
    }
    
    T* find_helper(Node<T>* root, T data) const
    {
        if (root == nullptr)
        {
            return nullptr;
        }
        if (root->data == data)
        {
            return &root->data;
        }
        else if (root->data > data)
        {
            return find_helper(root->left, data);
        }
        else if (root->data < data)
        {
            return find_helper(root->right, data);
        }
        return nullptr;
    }

    void insert_helper(Node<T>*& ptr, T data)
    {
        if (ptr == nullptr)
        {
            ptr = new Node<T>(data);
        }
        if (ptr->data == data)
        {
            return;
        }
        else if (ptr->data > data)
        {
            insert_helper(ptr->left, data);
            ptr->left->parent = ptr;
        }
        else if (ptr->data < data)
        {
            insert_helper(ptr->right, data);
            ptr->right->parent = ptr;
        }
    }
    
    void merge_helper(Node<T>*& obj1, const Node<T>* obj2)
    {   
        if (obj2 == nullptr)
        {   
            return;
        }
        if (obj1 == nullptr)
        {   
            obj1 = new Node<T>(obj2->data);
        }
        merge_helper(obj1, obj2->left);
        insert_helper(obj1, obj2->data);
        merge_helper(obj1, obj2->right);
        insert_helper(obj1, obj2->data);
    }
    
    Node<T>* left_rotate_help(Node<T>*& node)
    {
        if (node->right->left == nullptr)
        {
            node->parent = node->right;
            node->right->parent = nullptr;
            node->right->left = node;
            node->right = nullptr;
        }
        else
        {
            node->parent = node->right;
            node->right->parent = nullptr;
            node->right = node->parent->left;
            node->parent->left = node;
        }
        return node->parent;
    }

    Node<T>* right_rotate_help(Node<T>*& node)
    {
        if (node->left->right == nullptr)
        {
            node->parent = node->left;
            node->left->parent = nullptr;
            node->left->right = node;
            node->left = nullptr;
        }
        else
        {
            node->parent = node->left;
            node->left->parent = nullptr;
            node->left = node->parent->right;
            node->parent->right = node;
        }
        return node->parent;
    }
    
    
    
    void balance_helper(Node<T>*& node)
    {
        if (node == nullptr)
        {   
            return;
        }
        else
        {
            return;
        }
        if (node->balfactor > 1 && node->left->balfactor > 0)
        {
            node = left_rotate(node);
        }
        else
        {
            node = left_right_rotate(node);
        }
        if (node->balfactor < 1 && node->right->balfactor < 0)
        {
            node = right_rotate(node);
        }
        else
        {
            node = right_left_rotate(node);
        }
    }
    
public:

    void insert(T data)
    {
        insert_helper(root, data);
    }
    
    void left_rotate()
    {
        root = left_rotate_help(root);
    }

    void right_rotate()
    {
        root = right_rotate_help(root);
    }
    
    void left_right_rotate()
    {   
        root = left_right_rotate_help(root);
    }
    
    void right_left_rotate()
    {
        root = right_left_rotate_help(root);
    }
    
    void clear()
    {
        if (root == nullptr)
        {
            return;
        }
        clear_helper(root);
    }
    
    int get_height()
    {
        if (root == nullptr)
        {
            return 0;
        }
        return node_height(root);
    }
    
    void merge(const AVL& obj)
    {
        if (this == &obj)
        {
            return;
        }
        merge_helper(root, obj.root);
    }
   
    int get_number_of_nodes() const
    {
        if (root == nullptr)
        {
            return 0;
        }
        return nodes_number(root);
    }
    
    void preorder()
    {
        if (root == nullptr)
        {   
            return;
        }
        preorder_helper(root);
    }
    
    void inorder()
    {
        if (root == nullptr)
        {
            return;
        }
        inorder_helper(root);
    }
    
    void postorder()
    {
        if (root == nullptr)
        {
            return;
        }
        postorder_helper(root);
    }
    
    void levelorder()
    {
        if (root == nullptr)
        {
            return;
        }
        std::cout << root->data << ' ';
        levelorder_helper(root);
    }

    T get_root_data()
    {
        return root->data;
    }
    
    bool contains(T data)
    {
        if (root == nullptr)
        {
            return false;
        }
        return contains_helper(root, data);
    }

    T* find(T data) const
    {
        if (root->data == data)
        {
            return &root->data;
        }
        return find_helper(root, data);
    }
};
