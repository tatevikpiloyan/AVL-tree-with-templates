#include <iostream>
#include <initializer_list>

template <typename T>
class AVL
{
public:
  template<typename>
  struct Node
  {
    T data;
    Node* left;
    Node* right;
    Node* parent;
    int balfact;
    Node(T elem) : data(elem), left(nullptr), right(nullptr), parent(nullptr) {}
  };
  
private:
  Node<T>* root;

public:
  AVL() : root(nullptr) {}
  
  AVL(T data)
    {
        root = new Node<T>(data);
    }
  
  AVL(std::initializer_list<T> elem)
  {
    for (auto init : elem)
    {
      insert(init);
    }
  }
  
  AVL(const AVL& node)
  {
    root = deep_copy(node.root);
  }
  
  AVL(AVL&& node)
  {
    root = node.root;
    node.root = nullptr;
  }
  
  ~AVL()
  {
    if(root != nullptr)
    {
      clear_helper(root);
    }
  }
  
public:
  AVL& operator=(const AVL& node)
    {
        if (root == node.root)
        {
            return this;
        }
        if (root != nullptr)
        {
            clear(root);
        }
        root = deep_copy(node.root);
        return *this;
    }

    AVL& operator=(AVL&& node)
    {
        if (root == node.root)
        {
            return this;
        }
        if (root != nullptr)
        {
            clear(root);
        }
        root = node.root;
        node.root = nullptr;
        return *this;
    }

    friend std::ostream& operator<<(std::ostream& os, const AVL& obj)
    {
        print(os, obj.root);
        return os;
    }

    friend bool operator==(const AVL& obj1, const AVL& obj2)
    {   
        if (get_number_of_nodes(obj1.root) != get_number_of_nodes(obj2.root))
        {
            return false;
        }   
        return cmp(obj1.root, obj2.root);
    }

    friend bool operator!=(const AVL& obj1, const AVL& obj2)
    {   
        return !(obj1 == obj2);
    }
  
private:
  Node* deep_copy(Node<T>* node_ptr)
  {
    Node<T>* ptr = nullptr;
    if (node_ptr == nullptr)
    {
      return ptr;
    }
    ptr = new Node<T>();
    ptr->data = node_ptr->data;
    ptr->left = deep_copy(node_ptr->left);
    ptr->right = deep_copy(node_ptr->right);
    return ptr;
  }
  
  void print(std::ostream& os, const Node<T>* root)
    {
        if (root == nullptr)
        {
            return;
        }
        print(os, root->left);
        os << root->data << ' ';
        print(os, root->right);
    }
    
    bool cmp(const Node<T>* obj1, const Node<T>* obj2)
    {
        if (obj1 == nullptr && obj2 == nullptr)
        {
            return true;
        }
        if (obj1->data != obj2->data)
        {
            return false;
        }
        return cmp(obj1->left, obj2->left) && cmp(obj1->right, obj2->right);
    }
    
    void clear_helper(Node<T>* ptr)
    {
        if (ptr == nullptr)
        {
            return;
        }
        clear_helper(ptr->left);
        clear_helper(ptr->right);
        delete ptr;
        ptr = nullptr;
    }
    
    int nodes_number(const Node<T>* ptr)
    {
        if(ptr == nullptr)
        {
            return 0;
        }
        return 1 + get_number_of_nodes(ptr->left) + get_number_of_nodes(ptr->right);
    }
    
    int node_height(const Node<T>* node)
    {
        if (node == nullptr)
        {
            return 0;
        }
        return 1 + ((node_height(node->left) > node_height(node->right)) ? node_height(node->left) : node_height(node->right));
    }
    bool contains_helper(const Node* node, T data)
    {
        if (node == nullptr)
        {
            return false;
        }
        if (node->data == data)
        {
            return true;
        }
        else if (node->data > data)
        {
            return contains_helper(node->left, data);
        }
        else if (node->data < data)
        {
            return contains_helper(node->right, data);
        }
    }
    
    void preorder_helper(const Node<T>* node)
    {
        if (node == nullptr)
        {   
            return;
        }
        std::cout << node->data << ' ';
        preorder_helper(node->left);
        preorder_helper(node->right);
    }
    
    void inorder_helper(const Node<T>* node)
    {
        if (node == nullptr)
        {   
            return;
        }
        inorder_helper(node->left);
        std::cout << node->data << ' ';
        inorder_helper(node->right);
    }
    
    void postorder_helper(const Node<T>* node)
    {
        if (node == nullptr)
        {   
            return;
        }
        postorder_helper(node->left);
        postorder_helper(node->right);
        std::cout << node->data << ' ';
    }
    
public:
    void clear()
    {
        if (root == nullptr)
        {
            return;
        }
        clear_helper(root);
    }
   
    int get_number_of_nodes()
    {
        if (root == nullptr)
        {   
            return 0;
        }
        return nodes_number(root);
    }
    
    void preorder()
    {
        if (root == nullptr)
        {   
            return;
        }
        preorder_helper(root);
    }
    
    void inorder()
    {
        if (root == nullptr)
        {
            return;
        }
        inorder_helper(root);
    }
    
    void postorder()
    {
        if (root == nullptr)
        {
            return;
        }
        postorder_helper(root);
    }

    T get_root_data()
    {
        return root->data;
    }

    int get_height()
    {
        if (root == nullptr)
        {
            return 0;
        }
        return tree_height(root);
    }
    
    bool contains(T data)
    {
        if (root == nullptr)
        {
            return false;
        }
        return contains_helper(root, data);
    }
};
